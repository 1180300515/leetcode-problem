# 数组 & 字符串
## 基本方法：
1. 双指针：
     - 指头+指尾
     - 一快一慢
2. 排序算法：  
    -  暴力


- <span style="font-size: 24px;">88. 合并两个有序数组</span>   

**解法**  
双指针，谁出，指针增加。

- <span style="font-size: 24px;">27. 移除元素</span>   

**解法**   
移动，找到待移除元素，和后面非第一个非移除元素交换位置（顺序不可变情况）。   
顺序可变：双指针，头尾

- <span style="font-size: 24px;">26. 删除有序数组中的重复项 & 80. 删除有序数组中的重复项 II</span>   

**解法**  
双指针，第一个指针，一个位置一个位置走，第二个指针，找出来所有不同的，交换位置即可。   

针对2： 需要加一个记录，也就是第一个指针的数出现的次数。**（最普遍方法）**   

**优化**  
对于一个结果来说，同一个数最多出现两次，那么就可以和前两位数比较，而不是和前一位数比较

- <span style="font-size: 24px;">169. 多数元素</span>

**解法**  
1. 哈希表记录，看结果只有一个，每次哈希表动就进行个判断，符合就返回。  
2. 随机化：随机选个数，算出现次数。一直循环。期望为O(n)。
3. Boyer-Moore 投票算法：
```
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：
	如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
	如果 x 与 candidate 不等，那么计数器 count 的值减少 1。
在遍历完成后，candidate 即为整个数组的众数。
```
- <span style="font-size: 24px;">189. 轮转数组</span>

**解法**  
相当于一个映射，找到映射规律，交换即可。(错误思路)
1. 交换的位置好计算，换完存储被替换的值，算这个值的位置，之后一直重复到回到起点。同时记录一个count，如果count等于数组长，结束，否则需要继续。
2. 数组反转，先进行一个整体反转，之后依据轮转数，前半部分反转，后半部分反转。	  
1 2 3 4 5	k=2   
5 4 3 2 1   
4 5 3 2 1   
4 5 1 2 3



# 图问题
## 基本方法：
1. 深度优先和广度优先   
2. floyd算法（求图中点到点最短距离）
- <span style="font-size: 24px;">130. 被围绕的区域</span>

**误区:**   
此题我的思路符合起始的深度优先，但是缺忽略了间接和'O'相连接的部分，导致出错。  
**解法:**   
同样的：区分每一个字符的三个状态：'X' , 被'X'环绕的'O'， 未被'X'环绕的'O'  
在深度优先遍历时：和边界'O'相连的标记为'A'   
最后：需要把'O'替换为'X', 把'A'替换成'O'

- <span style="font-size: 24px;">133. 克隆图</span>

**解法**  
依然是深度优先，dfs要做的是克隆当前节点

- <span style="font-size: 24px;">399. 除法求值</span>

**解法**  
深度优先   
踩坑：
1. 无向图，使用深度优先会出现死循环，使用足迹记录解决。
2. 使用深度优先的可能有结果，也可能没有结果，因此dfs需要返回判断结果。  

**floyd算法思路**  
前面的和我一样，先建立string到int的映射，然后算出来一个矩阵，表示除法的结果。   
使用floyd算法，先计算两个点之间的距离。  
之后再遍历直接查找。

**并查集**   
todo

- <span style="font-size: 24px;">207. 课程表 && 210. 课程表 II</span>

**超时**  
依然使用矩阵表示边，使用floyd算法算出来所有点到点的可达性。但是超时。   
（算法思想：选择每个点k作为中转点，遍历所有的节点对（i，j），如果（i，k）（k，j）均可达，那么（i，j）就可达）。   
**解析**   
拓扑排序：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。  
而存在环的有向图中，不存在拓扑排序。

**深度优先搜索**  
基本思想：     
每个点状态：未搜索，搜索中，已搜索    
选择一个未搜索过的点，从此点开始深度搜索，经过的点搜设置为搜索中。  

继续递归：  
点的后续未搜索，进入。

递归的返回：   
1. 当这个点的没有后续或者所有的后续都是已搜索，那么就返回。
2. 当这个点的后续是搜索中的点，那么说明存在环。设置标志，返回     

这个设计方式和我常用的不太一样，常用的是第一步就判断是否返回，然后再。。这种思路会多走一个点。   

**广度优先思想**   
即出度，入度的概念。   
先选出来入度为0的，然后删除这个点，调整该点后续节点的入度，在选出来入度为0的。以此类推。   
结束后包含所有的点，那么就没有环。

 
**优化**  
在我的设计中，我是用了一个map去记录一个点到所有点的可达性，但是当点非常多时，就会额外多出很多的遍历。   
导致同样的设计，我的时间为143ms，而题解为13ms。   
优化方式：依然是二维数组，但是每一行存储的是可达的节点列表。

- <span style="font-size: 24px;">909. 蛇梯棋</span> 

**解析**   
使用广度优先搜索，思路比较好想    

**超时**  
我的思路是：广度优先，入队列，每一回合弹出上一回合所有的，针对每一个算下一回合，压入。   
同时当每一个回合更新最大值，和上一次比较确定是否循环：**（思路错误）**
每次只管压入，并未考虑节点是否已经遍历，导致最外层的队列判空失效。

**题解**  
一个数组维护访问记录。    
队列中，每一个元素记录序号以及步数。（以此取消掉计数循环）  
每次只压入未访问的。（高效处理循环问题以及不可达问题）


- <span style="font-size: 24px;">433. 最小基因变化 && 127. 单词接龙</span> 

思路简单：建立一个map，维护一个节点的下一个可达节点。  
使用广度优先遍历。   
队列：元素（下标 + 步数）   

**待优化**  
每一次都要判断两个string是否是一个单词不同   

**优化**   
比如一个单词：hit，他的后续一定是 \*it, h\*t , hi\*。  
那么对于bit来说，他的后续有: \*it , b\*t, bi\*。   
也就是说从bit到hit，本来一步，现在变成了 bit -> \*it -> hit。   
但是省略了一个对比的过程。   
因此，对于每一个单词，将其所有的带*后续也作为节点加入到邻接矩阵中。   
在原来的思路中：map_中维护节点i的后续可能节点，但是这个后续节点需要一个一个的判断。因此对于一个节点，他的后续都是每一个位置替换成\*。这样就避免了对比的问题。    
同时，一个哈希表维护所有节点到id的映射。这样就可以实现id到id的map_记录。   
最终使用广度优先，一样的步骤，只需要结果/2即可。
   
**进一步优化**   
使用广度优先，其搜索空间不断变大，因此可以使用双向广度优先搜索，即起始节点进行搜索，同时目的节点也进行搜索，如果遇到一个都遍历过的。就结束。      
需要注意的是：不再是队列非空一直弹，而是一个回合一个回合的进行。
```
正向queue
访问记录

反向queue
访问记录

while(queue不空)：
	//正向
	依次弹出所有（同一个回合）:
		判断弹出点反向是否访问过
		判断，更新，入队列
	//反向
	同上
```

