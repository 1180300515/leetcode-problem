# 数组 & 字符串
## 基本方法：
1. 双指针：
     - 指头+指尾
     - 一快一慢


- <span style="font-size: 24px;">88. 合并两个有序数组</span>   

**解法**  
双指针，谁出，指针增加。

- <span style="font-size: 24px;">27. 移除元素</span>   

**解法**   
移动，找到待移除元素，和后面非第一个非移除元素交换位置（顺序不可变情况）。   
顺序可变：双指针，头尾

- <span style="font-size: 24px;">26. 删除有序数组中的重复项 & 80. 删除有序数组中的重复项 II</span>   

**解法**  
双指针，第一个指针，一个位置一个位置走，第二个指针，找出来所有不同的，交换位置即可。   

针对2： 需要加一个记录，也就是第一个指针的数出现的次数。**（最普遍方法）**   

**优化**  
对于一个结果来说，同一个数最多出现两次，那么就可以和前两位数比较，而不是和前一位数比较



# 图问题
## 基本方法：
1. 深度优先和广度优先   
2. floyd算法（求图中点到点最短距离）
- <span style="font-size: 24px;">130. 被围绕的区域</span>

**误区:**   
此题我的思路符合起始的深度优先，但是缺忽略了间接和'O'相连接的部分，导致出错。  
**解法:**   
同样的：区分每一个字符的三个状态：'X' , 被'X'环绕的'O'， 未被'X'环绕的'O'  
在深度优先遍历时：和边界'O'相连的标记为'A'   
最后：需要把'O'替换为'X', 把'A'替换成'O'

- <span style="font-size: 24px;">133. 克隆图</span>

**解法**  
依然是深度优先，dfs要做的是克隆当前节点

- <span style="font-size: 24px;">399. 除法求值</span>

**解法**  
深度优先   
踩坑：
1. 无向图，使用深度优先会出现死循环，使用足迹记录解决。
2. 使用深度优先的可能有结果，也可能没有结果，因此dfs需要返回判断结果。  

**floyd算法思路**  
前面的和我一样，先建立string到int的映射，然后算出来一个矩阵，表示除法的结果。   
使用floyd算法，先计算两个点之间的距离。  
之后再遍历直接查找。

**并查集**   
todo

- <span style="font-size: 24px;">207. 课程表 && 210. 课程表 II</span>

**超时**  
依然使用矩阵表示边，使用floyd算法算出来所有点到点的可达性。但是超时。   
（算法思想：选择每个点k作为中转点，遍历所有的节点对（i，j），如果（i，k）（k，j）均可达，那么（i，j）就可达）。   
**解析**   
拓扑排序：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。  
而存在环的有向图中，不存在拓扑排序。

**深度优先搜索**  
基本思想：     
每个点状态：未搜索，搜索中，已搜索    
选择一个未搜索过的点，从此点开始深度搜索，经过的点搜设置为搜索中。  

继续递归：  
点的后续未搜索，进入。

递归的返回：   
1. 当这个点的没有后续或者所有的后续都是已搜索，那么就返回。
2. 当这个点的后续是搜索中的点，那么说明存在环。设置标志，返回     

这个设计方式和我常用的不太一样，常用的是第一步就判断是否返回，然后再。。这种思路会多走一个点。   

**广度优先思想**   
即出度，入度的概念。   
先选出来入度为0的，然后删除这个点，调整该点后续节点的入度，在选出来入度为0的。以此类推。   
结束后包含所有的点，那么就没有环。

 
**优化**  
在我的设计中，我是用了一个map去记录一个点到所有点的可达性，但是当点非常多时，就会额外多出很多的遍历。   
导致同样的设计，我的时间为143ms，而题解为13ms。   
优化方式：依然是二维数组，但是每一行存储的是可达的节点列表。

- <span style="font-size: 24px;">909. 蛇梯棋</span> 

**解析**   
使用广度优先搜索，思路比较好想    

**超时**  
我的思路是：广度优先，入队列，每一回合弹出上一回合所有的，针对每一个算下一回合，压入。   
同时当每一个回合更新最大值，和上一次比较确定是否循环：**（思路错误）**
每次只管压入，并未考虑节点是否已经遍历，导致最外层的队列判空失效。

**题解**  
一个数组维护访问记录。    
队列中，每一个元素记录序号以及步数。（以此取消掉计数循环）  
每次只压入未访问的。（高效处理循环问题以及不可达问题）