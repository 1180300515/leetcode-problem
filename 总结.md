# 图问题
基础：深度优先和广度优先   
- <span style="font-size: 18px;">130. 被围绕的区域</span>

**误区:**   
此题我的思路符合起始的深度优先，但是缺忽略了间接和'O'相连接的部分，导致出错。  
**解法:**   
同样的：区分每一个字符的三个状态：'X' , 被'X'环绕的'O'， 未被'X'环绕的'O'  
在深度优先遍历时：和边界'O'相连的标记为'A'   
最后：需要把'O'替换为'X', 把'A'替换成'O'

- <span style="font-size: 18px;">133. 克隆图</span>

**解法**  
依然是深度优先，dfs要做的是克隆当前节点

- <span style="font-size: 18px;">399. 除法求值</span>

**解法**  
深度优先   
踩坑：
1. 无向图，使用深度优先会出现死循环，使用足迹记录解决。
2. 使用深度优先的可能有结果，也可能没有结果，因此dfs需要返回判断结果。  

**floyd算法思路**  
前面的和我一样，先建立string到int的映射，然后算出来一个矩阵，表示除法的结果。   
使用floyd算法，先计算两个点之间的距离。  
之后再遍历直接查找。

**并查集**   
todo

- <span style="font-size: 18px;">207. 课程表 && 210. 课程表 II</span>

**超时**  
依然使用矩阵表示边，使用floyd算法算出来所有点到点的可达性。但是超时。   
（算法思想：选择每个点k作为中转点，遍历所有的节点对（i，j），如果（i，k）（k，j）均可达，那么（i，j）就可达）。   
**解析**   
拓扑排序：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。  
而存在环的有向图中，不存在拓扑排序。

**深度优先搜索**  
基本思想：     
每个点状态：未搜索，搜索中，已搜索    
选择一个未搜索过的点，从此点开始深度搜索，经过的点搜设置为搜索中。  

继续递归：  
点的后续未搜索，进入。

递归的返回：   
1. 当这个点的没有后续或者所有的后续都是已搜索，那么就返回。
2. 当这个点的后续是搜索中的点，那么说明存在环。设置标志，返回     

这个设计方式和我常用的不太一样，常用的是第一步就判断是否返回，然后再。。这种思路会多走一个点。   

**广度优先思想**   
即出度，入度的概念。   
先选出来入度为0的，然后删除这个点，调整该点后续节点的入度，在选出来入度为0的。以此类推。   
结束后包含所有的点，那么就没有环。

 
**优化**  
在我的设计中，我是用了一个map去记录一个点到所有点的可达性，但是当点非常多时，就会额外多出很多的遍历。   
导致同样的设计，我的时间为143ms，而题解为13ms。   
优化方式：依然是二维数组，但是每一行存储的是可达的节点列表。